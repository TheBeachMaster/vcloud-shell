function curl_wrapperLoggedInAbsoluteApiCall()
{
	local -ir curl_expectedHttpResponseCode=$1
	local -r verb="$2"
	local -r absolutePath="$3"
	
	declare -A curl_requestHeaders=()
	declare -A curl_responseHeaders=()
	local -i curl_httpResponseCode
	
	curl_wrapperSetAcceptHeader
	curl_requestHeaders['x-vcloud-authorization']="${api_token}"
	
	curl_wrapper "$verb" "$absolutePath"
	
	curl_validateResponseCode $curl_expectedHttpResponseCode "Could not connect to $absolutePath"
}

function curl_wrapperLoggedInRelativeApiCall()
{
	local -ir curl_expectedHttpResponseCode=$1
	local -r verb="$2"
	local -r relativePath="$3"
	
	curl_wrapperLoggedInAbsoluteApiCall $curl_expectedHttpResponseCode "$verb" "${api_map["${relativePath}"]}"
}

function curl_validateResponseCode()
{
	local -ir expectedResponseCode=$1
	local -r errorMessage="$2"
	
	if [ $curl_httpResponseCode -ne $expectedResponseCode ]; then
		informationMessage FAIL "$errorMessage (HTTP Response Code was $curl_httpResponseCode)"
		xml_starlet_keyValueTsv "Error" "$curl_downloadFilePath" '/_:Error' '@majorErrorCode' '@minorErrorCode' '@message' 1>&2
		exit 1
	fi
}

function curl_wrapperSetAcceptHeader()
{
	curl_requestHeaders['Accept']="application/*+xml;version=${configuration_api_version}"
}

function curl_wrapper()
{
	local -r verb="$1"
	
	local -r url="$2"
	
	temporaryFiles_newFileToRemoveOnExit
	local -r headersFilePath="$TMP_FILE"
	
	temporaryFiles_newFileToRemoveOnExit
	local -r stderrFilePath="$TMP_FILE"
	
	temporaryFiles_newFileToRemoveOnExit
	local -r downloadDetailsFilePath="$TMP_FILE"
	
	temporaryFiles_newFileToRemoveOnExit
	local -r asciiTraceFilePath="$TMP_FILE"
	
	declare -a curlArgs=()
	
	# -q as the first parameter prevents default configuration file loadings
	curlArgs+=('-q')
	
	# Arguments that can be overridden by configuration
	curlArgs+=('--user-agent' "$configuration_curl_userAgent")
	
	# Some of the vCloud API calls use redirection
	curlArgs+=('--max-redirs' "$configuration_curl_maxRedirs")
	
	curlArgs+=('--retry' "$configuration_curl_retries")
	
	# NOTE: Whilst this sequences of commands can add multiple --netrc switches, only the last is acted upon, unlike --config, which is acted on multiple times
	# Technically, .netrc only exists in $HOME, but we want to give a little more flexibility
	# netrc files have lines likes machine host.domain.com login myself password secret (machine X, username Y, password X)
	
	if [ -z "$netrcFilePath" ]; then
		curl_wrapperConfigArg --netrc-file "$CURL_HOME" .netrc
		curl_wrapperConfigArg --netrc-file "$HOME" .netrc
		curl_wrapperConfigArg --netrc-file /etc netrc
		curl_wrapperConfigArg --netrc-file "$HOME" "$ourName".netrc
		curl_wrapperConfigArg --netrc-file /etc "$ourName".netrc
	else
		curlArgs+=('--netrc-file' "$netrcFilePath")
	fi
	
	# Overridding of configuration occurs after setting are options; machine-wide always wins
	if [ -z "$curlrcFilePath" ]; then
		curl_wrapperConfigArg --config "$CURL_HOME" .curlrc
		curl_wrapperConfigArg --config "$HOME" .curlrc
		curl_wrapperConfigArg --config /etc curlrc
		curl_wrapperConfigArg --config "$HOME" "$ourName".curlrc
		curl_wrapperConfigArg --config /etc "$ourName".curlrc
		local configFile
		for configFile in /etc/"$ourName".d/curlrc.d/*.curlrc
		do
			if [ -f "$configFile" ]; then
				curlArgs+=('--config' "$configFile")
			fi
		done
	else
		curlArgs+=('--config' "$curlrcFilePath")
	fi
	
	# Override any setting of URL, TLS, etc after configuration loaded
	
	# more script-friendly output
	curlArgs+=('--silent' '--show-error')
	
	# Uses HTTP Date header if available to set the timestamp of any downloaded file
	curlArgs+=('--location')
	
	curlArgs+=('--tlsv1')
	
	#curlArgs+=('--compressed')
	
	curlArgs+=('--remote-time')
	
	local curl_requestHeader_name
	for curl_requestHeader_name in "${!curl_requestHeaders[@]}"
	do
		# ,, converts to lowercase. Whilst headers are case insensitive, using consistent casing makes life easier when debugging
		curlArgs+=('--header' "${curl_requestHeader_name,,}: ${curl_requestHeaders["$curl_requestHeader_name"]}")
	done
	
	# Verb
	case "$verb" in
		
		HEAD)
			curlArgs+=('--request' 'HEAD')
		;;
		
		GET)
			:
		;;
		
		POST)
			curlArgs+=('--data' '')
		;;
		
		DELETE)
			curlArgs+=('--request' 'DELETE')
		;;
		
		*)
			informationMessage FAIL "Verb $verb is not supported"
			exit 1
		;;
		
	esac
	
	# URL
	curlArgs+=('--url' "$url")
	
	# Output file, use - for stdout
	temporaryFiles_newFileToRemoveOnExit
	local -r actualDownloadFilePath="$TMP_FILE"
	curlArgs+=('--output' "$actualDownloadFilePath")
	
	# Headers file
	curlArgs+=('--dump-header' "$headersFilePath")
	
	# stderr file (a TMP_FILE could be appropriate)
	curlArgs+=('--stderr' "$stderrFilePath")
	
	# useful if debugging - redirection goes to downloadDetailsFilePath
	curlArgs+=('--write-out' '%{http_code}\t%{url_effective}\t%{ssl_verify_result}\t%{http_connect}\t%{time_total}\t%{size_download}\t%{speed_download}\t%{num_redirects}\n')
	
	# tracing of the connection (useful if debugging)
	curlArgs+=('--trace-time' '--trace-ascii' "$asciiTraceFilePath")
	
	set +e
	curl "${curlArgs[@]}" 1>"$downloadDetailsFilePath"
	local -ir exitCode=$?
	set -e
	
	if [ "$beDebug" = "yes" ]; then
		cat "$asciiTraceFilePath" 1>&2
	fi
	
	case $exitCode in
		
		0)
			curl_httpResponseCode="$(awk '{print $1}' "$downloadDetailsFilePath")"
			curl_downloadFilePath="$actualDownloadFilePath"
			
			while IFS=$'\t' read -r -d $'\n' name value
			do
				# terminated by two trailing lines
				if [ -z "$name" ]; then
					continue
				fi
				# ,, converts to lower case (makes headers consistent to work with)
				curl_responseHeaders["${name,,}"]="$value"
			done < <(tail -n +2 "$headersFilePath" | tr -d '\r' | awk -F': ' -v OFS=$'\t' '{print $1,$2}')
			
			return 0
		;;
		
		*)
			informationMessage FAIL "Failed to retrieve $url (exit code was $exitCode)"
			(
				echo
				echo "Standard Error was:-"
				cat "$stderrFilePath"
				echo
				echo "Download details were:-"
				cat "$downloadDetailsFilePath"
				echo
				echo "ASCII Trace was:-"
				cat "$asciiTraceFilePath"
			) 1>&2
			exit 1
		;;
		
	esac
}

function curl_wrapperConfigArg()
{
	local -r configSwitch="$1"
	local -r fileParentFolderEnvironmentVariable="$2"
	local -r fileName="$3"
	
	if [ -z "$fileParentFolderEnvironmentVariable" ]; then
		return 0
	fi
	
	local -r filePath="${fileParentFolderEnvironmentVariable}"/"${fileName}"
	
	if [ ! -f "$filePath" ]; then
		return 0
	fi
	if [ ! -r "$filePath" ]; then
		return 0
	fi
	if [ ! -s "$filePath" ]; then
		return 0
	fi
	curlArgs+=("$configSwitch" "$filePath")
}
