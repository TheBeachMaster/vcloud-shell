function capture()
{
	temporaryFiles_newFileToRemoveOnExit
	local -r captureFile="$TMP_FILE"
	
	"$@" >"$captureFile"
	
	captures[${lineNumber}]="$captureFile"
}

# eg  ./vsh api xml vdc_vApp 98-184-1-151d73 'Student Loans Company - Platform Engineering (IL0-TRIAL-BASIC)' 'man_dc'
# echo "api xml vdc_vApp 98-184-1-151d73 'Student Loans Company - Platform Engineering (IL0-TRIAL-BASIC)' 'man_dc'" | ./vsh
function api()
{
	if [ $# -lt 2 ]; then
		exitError "api must specify <format> <action>"
	fi
	local main_format="$1"
	local -r apiCommand="$2"
	shift 2
	
	api_command_${apiCommand} "$@"
}

function format()
{
	if [ $# -lt 3 ]; then
		exitError "format must specify <format> <with-header> <action>"
	fi
	
	local main_format="$1"
	local defaults_outputHeadingLine="$2"
	local -r formatCommand="$3"
	shift 3
	
	local curl_downloadFilePath
	for curl_downloadFilePath in "$@"
	do
		api_format_${formatCommand}
	done
}

function reset()
{
	local key
	for key in "${!api_downloadsCache[@]}"
	do
		unset api_downloadsCache["${key}"]
	done
}

function api_callbackGetHrefFromName()
{
	local -r linksTsvFile="$1"
	local -r resourceKind="$2"
	local -r resourceName="$3"
	
	local href mimeType name
	while IFS=$'\t' read -r -d $'\n' href mimeType name
	do
		if [ "$name" = "$resourceName" ]; then
			foundHref="$href"
			break
		fi
	done <"$linksTsvFile"
	
	if [ -z "$foundHref" ]; then
		informationMessage FAIL "Could not find $resourceKind $resourceName"
		exitError 1
	fi
}

function api_callbackGetHrefFromMimeType()
{
	local -r linksTsvFile="$1"
	local -r resourceKind="$2"
	local -r resourceMimeType="$3"
	
	local href mimeType rel
	while IFS=$'\t' read -r -d $'\n' href mimeType rel
	do
		if [ "$mimeType" = "$resourceMimeType" ]; then
			foundHref="$href"
			break
		fi
	done <"$linksTsvFile"
	
	if [ -z "$foundHref" ]; then
		informationMessage FAIL "Could not find $resourceKind mime-type $resourceMimeType"
		exitError 1
	fi
}

function api_callbackGetHrefFromRel()
{
	local -r linksTsvFile="$1"
	local -r resourceKind="$2"
	local -r resourceRel="$3"
	
	local href mimeType rel
	while IFS=$'\t' read -r -d $'\n' href mimeType rel
	do
		if [ "$rel" = "$resourceRel" ]; then
			foundHref="$href"
			break
		fi
	done <"$linksTsvFile"
	
	if [ -z "$foundHref" ]; then
		informationMessage FAIL "Could not find $resourceKind rel $resourceRel"
		exitError 1
	fi
}

function api_callbackGetHrefFromNameAndMimeType
{
	local -r linksTsvFile="$1"
	local -r resourceKind="$2"
	local -r resourceName="$3"
	local -r resourceMimeType="$4"
	
	local href mimeType name
	while IFS=$'\t' read -r -d $'\n' href mimeType name
	do
		if [ "$name" = "$resourceName" ]; then
			if [ "$mimeType" = "$resourceMimeType" ]; then
				foundHref="$href"
				break
			fi
		fi
	done <"$linksTsvFile"
	
	if [ -z "$foundHref" ]; then
		informationMessage FAIL "Could not find $resourceKind name $resourceName mime-type $resourceMimeType"
		exitError 1
	fi
}

function api_makeCallAndFindHrefInLinksAndPost()
{
	local -r ourFormat="$1"
	local -r callback="$2"
	local -r resourceKind="$3"
	local -r resourceNameOrMimeType="$4"
	local -r queryString="$5"
	local -r contentType="$6"
	shift 6
	
	temporaryFiles_newFileToRemoveOnExit
	local -r linksTsvFile="$TMP_FILE"
	
	main_format="$ourFormat" defaults_outputHeadingLine=0 "$@" >"$linksTsvFile"
	
	local foundHref=""
	${callback} "$linksTsvFile" "$resourceKind" "$resourceNameOrMimeType"
	curl_wrapperLoggedInAbsoluteApiCall 202 POST "${foundHref}${queryString}" "Content-Type" "${contentType}"
	
	downloads[${lineNumber}]="$curl_downloadFilePath"
}

function api_makeCallAndFindHrefInLinksAndDelete()
{
	local -r ourFormat="$1"
	local -r callback="$2"
	local -r resourceKind="$3"
	local -r resourceNameOrMimeType="$4"
	local -r queryString="$5"
	shift 5
	
	temporaryFiles_newFileToRemoveOnExit
	local -r linksTsvFile="$TMP_FILE"
	
	main_format="$ourFormat" defaults_outputHeadingLine=0 "$@" >"$linksTsvFile"
	
	local foundHref=""
	${callback} "$linksTsvFile" "$resourceKind" "$resourceNameOrMimeType"
	curl_wrapperLoggedInAbsoluteApiCall 202 DELETE "${foundHref}${queryString}"

	downloads[${lineNumber}]="$curl_downloadFilePath"
}

function api_makeCallAndFindHrefInLinksAndGet()
{
	local -r ourFormat="$1"
	local -r callback="$2"
	local -r resourceKind="$3"
	local -r resourceNameOrMimeType="$4"
	local -r queryString="$5"
	shift 5
	
	temporaryFiles_newFileToRemoveOnExit
	local -r linksTsvFile="$TMP_FILE"
	
	main_format="$ourFormat" defaults_outputHeadingLine=0 "$@" >"$linksTsvFile"
	
	local foundHref=""
	${callback} "$linksTsvFile" "$resourceKind" "$resourceNameOrMimeType"
	curl_wrapperLoggedInAbsoluteApiCall 200 GET "${foundHref}${queryString}"
	
	downloads[${lineNumber}]="$curl_downloadFilePath"
}

api_loggedOut=0
function api_logout()
{
	if [ $api_loggedOut -eq 1 ]; then
		return 0
	fi
	api_loggedOut=1
	
	# don't logout if curl was the cause of the error (eg because a retry timed out)
	if [ $curl_lastExitCode -ne 0 ]; then
		return 0
	fi
	
	local curl_downloadFilePath
	main_format=none defaults_outputHeadingLine=0 curl_wrapperLoggedInAbsoluteApiCall 204 DELETE "$api_logoutAbsoluteUrl"
}

api_token=""
api_logoutAbsoluteUrl=""
function api_sessions()
{
	declare -A curl_requestHeaders=()
	declare -A curl_responseHeaders=()
	local -i curl_httpResponseCode
	local curl_downloadFilePath
	
	curl_wrapperSetAcceptHeader
	local -r url="${api_map['/api/sessions']}"
	curl_post="" curl_wrapper POST "$url"
	
	curl_validateResponseCode 200 "Could not connect to $url"
	
	if [ $curl_httpResponseCode -ne 200 ]; then
		informationMessage FAIL "Could not log in to $switch_baseUrl (HTTP Response Code was $curl_httpResponseCode)"
		exit 1
	fi
	
	api_token="${curl_responseHeaders['x-vcloud-authorization']}"
	
	#down	application/vnd.vmware.vcloud.orgList+xml	https://api.vcd.portal.skyscapecloud.com/api/org/	
	#remove		https://api.vcd.portal.skyscapecloud.com/api/session/	
	#down	application/vnd.vmware.admin.vcloud+xml	https://api.vcd.portal.skyscapecloud.com/api/admin/	
	#down	application/vnd.vmware.vcloud.org+xml	https://api.vcd.portal.skyscapecloud.com/api/org/3a2900f9-f15c-49d6-8771-bdd8bbebe456	98-184-1-151d73
	#down	application/vnd.vmware.vcloud.query.queryList+xml	https://api.vcd.portal.skyscapecloud.com/api/query	
	#entityResolver	application/vnd.vmware.vcloud.entity+xml	https://api.vcd.portal.skyscapecloud.com/api/entity/	
	#down:extensibility	application/vnd.vmware.vcloud.apiextensibility+xml	https://api.vcd.portal.skyscapecloud.com/api/extensibility
	local relation
	local href
	local mimeType
	local name
	local apiKey
	# bash seems to be compressing empty fields
	while IFS=$'\t' read -r -d $'\n' relation href mimeType name
	do
		# Probably the 'remove' link
		if [ -z "$mimeType" ]; then
			apiKey=/api/session/
		else
			case "$mimeType" in
			
				application/vnd.vmware.vcloud.orgList+xml)
					apiKey=/api/org/
				;;
				
				application/vnd.vmware.admin.vcloud+xml)
					apiKey=/api/admin/
				;;
				
				# name
				application/vnd.vmware.vcloud.org+xml)
					#"$name"
					continue
					#apiKey=/api/org/3a2900f9-f15c-49d6-8771-bdd8bbebe456
				;;
				
				application/vnd.vmware.vcloud.query.queryList+xml)
					apiKey=/api/query
				;;
				
				application/vnd.vmware.vcloud.entity+xml)
					apiKey=/api/entity/
				;;
				
				application/vnd.vmware.vcloud.apiextensibility+xml)
					apiKey=/api/extensibility
				;;
				
				*)
					continue
				;;
				
			esac
		fi
		
		api_map["$apiKey"]="$href"
		
	# _: means the default namespace (not needed if there's no xmlns definition)
	done < <(defaults_outputHeadingLine=0 xml_starlet_tsv_downloadFilePath '/_:Session/_:Link' '@rel' '@href' '@type' '@name')
	
	api_logoutAbsoluteUrl="${api_map['/api/session/']}"
}

function api_versions()
{
	local -r escapedRelativePathIncludingAnyLeadingAndTrailingSlashes='/api/versions'
	api_map["$escapedRelativePathIncludingAnyLeadingAndTrailingSlashes"]="${switch_baseUrl}${escapedRelativePathIncludingAnyLeadingAndTrailingSlashes}"
	# found from /api/admin/<uuid>, not in the map from /api/sessions
	api_map['/api/supportedSystemsInfo/']="${switch_baseUrl}/api/supportedSystemsInfo/"
	
	declare -A curl_requestHeaders=()
	declare -A curl_responseHeaders=()
	local -i curl_httpResponseCode
	local curl_downloadFilePath
	
	local -r url="${api_map["$escapedRelativePathIncludingAnyLeadingAndTrailingSlashes"]}"
	curl_wrapper GET "$url"
	
	curl_validateResponseCode 200 "Could not connect to $url"
	
	# _: means the default namespace (not needed if there's no xmlns definition)
	temporaryFiles_newFileToRemoveOnExit
	local -r tsvFilePath="$TMP_FILE"
	defaults_outputHeadingLine=0 xml_starlet_tsv_downloadFilePath '/_:SupportedVersions/_:VersionInfo' '_:Version' '_:LoginUrl' >"$tsvFilePath"
	
	if ! grep --quiet "^${defaults_api_version}"$'\t' "$tsvFilePath"; then
		informationMessage FAIL "API version (defaults_api_version) $defaults_api_version is not supported"
		exit 1
	fi
	
	local version
	local sessionsUrl
	IFS=$'\t' read -r -d $'\n' version sessionsUrl <<<"$(grep "^${defaults_api_version}"$'\t' "$tsvFilePath")"
	api_map['/api/sessions']="$sessionsUrl"
}
