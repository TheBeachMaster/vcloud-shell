#!/usr/bin/env bash

readonly tab=$'\t'
function informationMessage()
{
	local messageKind="$1"
	local message="$2"
	
	case "$messageKind" in
		
		WARN|FAIL)
			echo "$ourName: $messageKind: $message" 1>&2
		;;
		
		DEBUG)
			if [ "$switch_beDebug" = "yes" ]; then
				echo "$ourName: $messageKind: $message" 1>&2
			fi
		;;
		
		*)
			if [ "$switch_beVerbose" = "yes" ]; then
				echo "$ourName: $messageKind: $message" 1>&2
			fi
		;;
	
	esac
}

# The purpose of these functions is to provide internal implementations of logic we can't be 100%
# sure of exists in the environment or is implemented as we would like for critical pieces of code.
# Such a critical piece is code executed before and during command line arg parsing (eg exitError)
function purebash_dirname()
{
	local -r converted="${1%/*}"
	if [ "$converted" = "$1" ]; then
		echo "."
	else
		echo "$converted"
	fi
}

function purebash_basename()
{
	echo "${1##*/}"
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export VCLOUD_CURL_BASH_DEBUGGING="yes"
	elif [ ! -z "$VCLOUD_CURL_BASH_DEBUGGING" ]; then
		if [ "$VCLOUD_CURL_BASH_DEBUGGING" = "yes" ]; then
			set -x
		fi
	fi
}

function setSaneEnvironmentDefaults()
{
	set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi
	
	unset BASH_ENV
	unset BASH_XTRACEFD
	unset CDPATH
	unset ENV
	unset FCEDIT
	unset FIGNORE
	unset FUNCNEST
	unset GLOBIGNORE
	unset HISTCONTROL
	unset HISTFILE
	unset HISTFILESIZE
	unset HISTIGNORE
	unset HISTSIZE
	unset HISTTIMEFORMAT
	unset HOSTFILE
	unset IGNOREEOF
	unset INPUTRC
	unset MAIL
	unset MAILCHECK
	unset MAILPATH
	unset TMOUT
	
	umask 022
}

function findOurNameAndPath()
{
	readonly ourName="$(purebash_basename "$0")"
	pushd "$(purebash_dirname "$0")" >/dev/null
		readonly crudeOurPath="$(pwd)"
	popd >/dev/null
}

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	exit 1
}

function exitHelp()
{
	echo -n -E "Usage: ${ourName} -h
Usage: ${ourName} [-v] [-d] [-c switch_configPath] [-n switch_netrcFilePath ] [-r switch_curlrcFilePath] [-f switch_format] [-t switch_outputHeadingLine] -- command <args>

Argument-less Switches
    Switch  Explanation            Default       Configuration*
    -h      show this help
    -v      be more verbose        ${beVerbose}  beVerbose
    -d      output debug messages  ${beDebug}    beDebug

Argumented Switches
    Switch  Configuration*            Default
    -c      switch_configPath         ${switch_configPath}
    -n      switch_netrcFilePath      ${switch_netrcFilePath} (not used if not present)
    -r      switch_curlrcFilePath     ${switch_curlrcFilePath} (not used if not present)
    -u      switch_baseUrl            ${switch_baseUrl}
    -f      switch_format             ${switch_format}
    -t      switch_outputHeadingLine  ${switch_outputHeadingLine} (yes|on|true|1 or no|off|false|0)
    --                                End of arguments, beginning of commands

*See below

command
This is a command followed by optional <args>. Supported commands are:-

    orgs        List of organisations
    org <name>  Org details for <name>, eg 98-184-1-151d73

Configuration
Command line switches (switch_) can be specified using a key=value file (with quoting if value contains spaces or characters special to the shell).
By default, the following locations are searched and files sourced as configuration in order before the command line is processed:-

    ~/.${ourName}
    <VCLOUD_CURL_CONFIGURATION>  (an environment variable)

Format
Format controls output. The list of valid switch_formats varies by command, but xml is always supported and links produces links.

netrc Files
netrc files and are used to specify user name and password credentials. netrc files are searched for automatically
unless  -n switch_netrcFilePath  is specified.
The locations searched in order are:-

    <CURL_HOME>/.netrc
    <HOME>/.netrc
    ${etcPath}/netrc
    <switch_configPath>/netrc
    <HOME>/$ourName.netrc

If more than one file is found, then the last one found is the one used.

The netrc file should consist of lines in the switch_format machine HOSTNAME login USER@ORGANIZATION password PASSWORD. The first
matching entry is used, or, if no matching entries are present, the final 'default' entry. More details are in  man 5 netrc.

HOSTNAME should be that of the vCloud portal. For Skyscape, it is  api.vcd.portal.skyscapecloud.com . In the vCloud 5.1 API
documentation, this is the value 'vcloud.example.com'.

curlc Files
curlrc files are used to specify additional options for curl. A typical use case is to configure proxy servers. curlc files are searched
for automatically unless  -r switch_curlrcFilePath is specified.  By default, the locations searched in order are:-

    <CURL_HOME>/.curlrc
    <HOME>/.curlrc
    ${etcPath}/curlrc
    <switch_configPath>/curlrc
    <switch_configPath>/curlrc.d/*.curlrc
    <HOME>/$ourName.curlrc
    <switch_curlrcFilePath>

If more than one file is found, then all are used, with any conflicting settings resolved with 'last one wins'.

Please note that not all curl configuration will be honoured, as we explicitly set --url, etc

Defaults
Defaults are used to control common use cases. Defaults for values are sourced as key=value pairs from the following locations:-
    
    Location                                   Currently
    <switch_configPath>/defaults               ${switch_configPath}.d/defaults
    <switch_configPath>/defaults.d/*.defaults  ${switch_configPath}.d/defaults.d/*.defaults

The values that can be configured are:-
    
    Value                     Built-in Value
    defaults_api_version      ${defaults_api_version}
    defaults_curl_userAgent   ${defaults_curl_userAgent}
    defaults_curl_maxRedirs   ${defaults_curl_maxRedirs}
    defaults_curl_retries     ${defaults_curl_retries}

Paths
A path is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies. The PATH variable is reset to empty if they are used. Paths are used if a file
<switch_configPath>/paths.d/<distributionName> exists for the detected <distributionName>.
" 1>&2
	exit $1
}

commandLineCommand=""
commandLineArgs=()
function loadAnyConfiguration()
{
	switch_language="en_GB.UTF-8"
	switch_beVerbose="no"
	switch_beDebug="no"
	
	switch_netrcFilePath=""
	switch_curlrcFilePath=""
	switch_baseUrl="https://api.vcd.portal.skyscapecloud.com"
	switch_format="xml"
	switch_outputHeadingLine=1
	
#start VCLOUD_CURL_CONFIG_PATH
	etcPath="/etc"
	switch_configPath="$crudeOurPath"/config
#end VCLOUD_CURL_CONFIG_PATH
#start VCLOUD_CURL_DEFAULTS
	# Insert all our defaults as shipped, too
#end VCLOUD_CURL_DEFAULTS
	
	local -r userConfiguration=~/."$ourName"
	if [ -r "$userConfiguration" ]; then
		source "$userConfiguration"
	fi
	
	local -r environmentVariableConfiguration="$VCLOUD_CURL_CONFIGURATION"
	if [ -n "$environmentVariableConfiguration" ]; then
		if [ -r "$environmentVariableConfiguration" ]; then
			source "$VCLOUD_CURL_CONFIGURATION"
		fi
	fi
}

function parseCommandLine()
{
	local OPTERR=1
	local OPTIND=1
	local OPTARG
	local option
	while getopts :hvdc:s:n:r:f:t: option
	do
		case "$option" in
			
			h)
				exitHelp 2
			;;
			
			v)
				switch_beVerbose="yes"
			;;
			
			d)
				switch_beDebug="yes"
			;;
			
			c)
				switch_configPath="$OPTARG"
			;;
			
			u)
				switch_baseUrl="$OPTARG"
			;;
			
			n)
				switch_netrcFilePath="$OPTARG"
			;;
			
			r)
				switch_curlrcFilePath="$OPTARG"
			;;
			
			f)
				switch_format="$OPTARG"
			;;
			
			t)
				case "$OPTARG" in
					
					1|yes|true|on)
						switch_outputHeadingLine=1
					;;
					
					0|no|true|off)
						switch_outputHeadingLine=0
					;;
					
					*)
						switch_outputHeadingLine=1
					;;
					
				esac
			;;
			
			'?')
				exitError "Invalid option -${OPTARG}"
			;;
			
		esac
	done
	
	shift $((OPTIND - 1))
	
	commandLineCommand=("$1")
	shift 1
	commandLineArgs=("$@")
	
	function makeCommandLinePathsAbsolute()
	{
		pushd "$switch_configPath" 1>/dev/null
			switch_configPath="$(pwd)"
		popd 1>/dev/null
	}
	makeCommandLinePathsAbsolute
}

function validateCommandLineArguments()
{
	if [ ! -d "$switch_configPath" ]; then
		exitError "Config path $switch_configPath does not exist or is not a directory"
	fi
	
	if [ -n "$switch_netrcFilePath" ]; then
		if [ ! -f "$switch_netrcFilePath" ]; then
			exitError "-n switch_netrcFilePath $switch_netrcFilePath does not exist or is not a file"
		fi
	fi
	
	if [ -n "$switch_curlrcFilePath" ]; then
		if [ ! -f "$switch_curlrcFilePath" ]; then
			exitError "-r switch_curlrcFilePath $switch_curlrcFilePath does not exist or is not a file"
		fi
	fi
	
	if [ -z "${commandLineCommand}" ]; then
		exitError "Please specify a command for the commandLine"
	fi
}

#start VCLOUD_CURL_SOURCE_FUNCTIONS
function sourceFunctions()
{
	sourceFunctionsRecursively "$crudeOurPath"/functions
}

function sourceFunctionsRecursively()
{
	local -r pathToFunctions="$1"
	pushd "$pathToFunctions" 1>/dev/null 2>/dev/null
		
		local functionFile
		for functionFile in *.functions
		do
			if [ -f "$functionFile" ]; then
				source "$functionFile"
			fi
		done
		
		local functionFolder
		for functionFolder in *
		do
			if [ -d "$functionFolder" ]; then
				sourceFunctionsRecursively "$functionFolder"
			fi
		done
		
	popd 1>/dev/null 2>/dev/null
}
#end VCLOUD_CURL_SOURCE_FUNCTIONS

function main()
{
	setDebugging
	setSaneEnvironmentDefaults
	findOurNameAndPath
	loadAnyConfiguration
	parseCommandLine "$@"
	validateCommandLineArguments
	
	sourceFunctions
	
	declare -A api_map
	main_executeMainFunctions
}

main "$@"
